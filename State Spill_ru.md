Характеристика утечки состояний в современных операционных системах Кевин Боос, Эмилио Дель Веккио и Линь Чжун Университет Райса {kevinaboos, edd5, lzhong}@rice.edu Аннотация Понимание и управление распространением состояний в операционных системах стало неразрешимой проблемой из-за их огромные размеры и сложность. Несмотря на усилия по модульности, она остается серьезным препятствием для многих современных вычислительных целей: миграции процессов, изоляции отказов и устойчивости, оперативного обновления, виртуализации программного обеспечения и многого другого. Хотя многие предыдущие исследования ОС достигали этих целей с помощью специальных и утомительных методов, мы утверждаем, что они упустили основную причину, почему эти цели настолько сложны: разлив состояния. Разлив состояния происходит, когда состояние программного объекта претерпевает долгосрочные изменения в результате транзакции от другого объекта. Чтобы повысить осведомленность о разливе состояния и его вредных последствиях, мы проводим тщательное исследование современных операционных систем и предлагаем классификацию шаблонов проектирования, вызывающих разлив состояния. Мы представляем STATES PY, автоматизированный инструмент, который использует совместный статический анализ и анализ времени выполнения для обнаружения утечки состояния в реальных программных объектах. Под руководством STATE S PY мы демонстрируем наличие утечки состояния в 94% системных служб Android. Наконец, мы анализируем вредные последствия разлива нефти из штатов и предлагаем альтернативные варианты и стратегии по их смягчению. 1. Введение За последние несколько десятилетий исследования операционных систем проделали большую работу для достижения целого ряда передовых вычислительных целей: миграция процессов, изоляция отказов и устойчивость, оперативное обновление, горячая замена, виртуализация, безопасность, общая простота обслуживания и т. д. и более. Лучшая модульность, при которой связанные функциональные возможности группируются в ограниченные сущности, часто рекламируется как наиболее подходящее решение для реализации таких целей, и на первый взгляд это кажется многообещающим. Однако мы утверждаем, что одной модульности недостаточно и что эффекты взаимодействия между модулями оказывают более выраженное влияние на эти цели, как показано ниже. Многие усилия по достижению этих целей были разовыми и привязанными к конкретной платформе из-за сложной природы того, как программное обеспечение. Разрешение на создание цифровых или печатных копий всей или части этой работы для личного использования или использования в классе предоставляется бесплатно при условии, что копии не изготовлены или распространены с целью получения прибыли или коммерческой выгоды, и что копии содержат это уведомление и полную цитату на первой странице. Авторские права на компоненты этой работы, принадлежащие другим лицам, кроме автора(ов), должны соблюдаться. Реферирование с кредитом разрешено. Копирование иным образом или повторная публикация, размещение на серверах или повторное распространение в списках требует предварительного специального разрешения и/или оплаты. Запросите разрешения по адресу Permissions@acm.org. EuroSys '17, 23–26 апреля 2017 г., Белград, Сербия © 2017 Авторские права принадлежат владельцу/автору(ам). Права на публикацию предоставлены ACM. ISBN 978-1-4503-4938-3/17/04. . . $15,00 DOI: http://dx.doi.org/10.1145/3064176.3064205 Состояния изменяются и распространяются по всей системе, показывая, что модульность необходима, но недостаточна. Например, в нескольких работах по миграции процессов упоминаются «остаточные зависимости», которые остаются в исходной системе, как препятствие для корректности постмиграции в целевой системе [38, 55, 34]. В литературе по изоляции отказов и отказоустойчивости уже давно осознаются нежелательные последствия разделения судеб между программными модулями, а также сложность восстановления процесса или всей машины с сохранением состояния после сбоя из-за разрастания состояний, распределенных между различными компонентами системы [28]. , 26, 52, 51]. Исследования в области оперативного обновления и горячей замены уже давно направлены на преодоление проблем обслуживания состояния и межмодульных зависимостей, которые мешают их реализации при переходе от старой версии к новой, вынуждая разработчиков писать сложные функции передачи состояния [7, 25, 27, 48, 5]. Аналогично, управление состоянием создает проблему для виртуализации произвольных программных компонентов, значительно усложняя логику мультиплексирования и изоляции базового уровня виртуализации (например, ядра или среды выполнения) [11, 6]. В этой статье наш основной вклад состоит в том, чтобы идентифицировать проблему разлива состояний как основную причину этих проблем и показать, что это основная причина того, почему многие вычислительные цели так трудно реализовать, даже перед лицом правильной модуляризации.Разлив состояния — это процесс, когда состояние одного программного объекта претерпевает устойчивые изменения в результате его взаимодействия с другим объектом. Например, если приложение взаимодействует с системной службой, в результате чего эта служба сохраняет состояния, относящиеся к приложению, в своей памяти, то происходит утечка состояния из приложения в службу. Формально мы определяем разлив состояния и условия, при которых он происходит, в §3. Из этого беглого объяснения становится очевидным, что утечка состояний — это явление, которое пронизывает все уровни программной системы. Однако это связано с выбором степени детализации объекта: взаимодействия, пересекающие границы объекта, считаются транзакциями, представляющими интерес, а взаимодействия внутри одного объекта — нет. Например, если степень детализации объекта определена как процесс, то вызов IPC между двумя процессами может представлять собой утечку состояния, а вызов локальной функции внутри процесса - нет. Определение разлива состояния не ограничивается детализацией какой-либо конкретной сущности; Детализация объекта — это решение, зависящее от платформы и цели (§3.1). Однако в этой работе наш анализ сосредоточен вокруг границ сущности, аналогичных границам модуля: сущность состоит из группы связанных функций и данных, которые они модифицируют. Например, при анализе системных служб Android лучшим выбором степени детализации сущностей является класс Java. Второй вклад этой работы — ручной анализ утечки состояния и ее пагубного воздействия на вышеупомянутые вычислительные цели в различных реальных ОС. Мы обнаружили, что утечка состояний часто является побочным продуктом применения принципа локальности к проектированию ОС, поскольку она часто возникает из-за выбора дизайна, который отдает предпочтение удобству программирования или производительности, а не соблюдению строгих принципов архитектуры или модульности. На основе этих тематических исследований мы устанавливаем классификацию утечки состояний (§4) в соответствии с общими шаблонами проектирования: уровни косвенности, мультиплексоры, диспетчеры и сотрудничество между объектами. Наш третий вклад — это инструмент STATES PY, который автоматизирует обнаружение утечки состояния в реальных системах, а также углубленный, управляемый инструментами анализ утечки состояния в объектах системных служб Android. Как описано в §5, STATE S PY использует методы как динамического, так и статического анализа, которые автоматизируют захват, проверку и дифференцирование состояния программного объекта, с текущей поддержкой сред Java. Компонент анализа времени выполнения STATES PY фиксирует состояние работающего объекта, вмешиваясь в пути выполнения объекта при обработке транзакций, вызываемых реальными приложениями. Наш ключевой подход к анализу времени выполнения заключается в использовании существующих платформ отладки для неинтрузивного захвата и сравнения состояний сущностей. Этот метод не учитывает функции, специфичные для конкретной среды, и распространяется на любую среду выполнения. Компонент статического анализа STATE S PY предоставляет фильтры релевантности компоненту среды выполнения как часть кооперативного цикла обратной связи, который итеративно улучшает выходные данные каждого компонента. Наш экспериментальный анализ системных служб Android (раздел 6), проведенный под руководством STATE S PY, показал, что вредоносная утечка состояния широко распространена и глубока: почти все системные службы Android имеют утечку состояния, и она часто происходит в цепочке между несколькими службами. В §7 мы обсуждаем, как смягчить последствия разлива состояний путем переосмысления существующих шаблонов проектирования программного обеспечения и схем связи. Модуляризации недостаточно: уменьшение влияния утечки состояния является ключом к упрощению программных компонентов и обеспечению их возможности миграции, оперативного обновления, восстановления после сбоев, виртуализации и других вычислительных задач. Фактически, мы показали, что системные службы Android можно сделать более отказоустойчивыми с помощью методов предотвращения утечки данных [17]. Таким образом, мы идентифицируем и формально определяем проблему утечки состояния в современных операционных системах, классифицируем ее различные воплощения и предоставляем инструмент, который помогает в обнаружении сложных воплощений утечки состояния. Суть этой работы заключается не в том, чтобы предложить полную картину утечки состояния в каждой ОС, а, скорее, в том, чтобы подчеркнуть существование утечки состояния как вредного явления и подчеркнуть его негативное влияние на реализацию многих современных компьютерных целей. STATE SPY имеет открытый исходный код и доступен по адресу [10]. 2. Предыстория и модель системы. Чтобы правильно определить разлив состояния и условия, при которых он происходит, мы сначала предполагаем системную модель с вложенной иерархией абстракций (рис. 1).Каждый уровень абстракции содержит один или несколько программных объектов — общий термин, охватывающий общие абстракции программирования и времени выполнения, например, процессы, потоки, модули, классы, функции. Различные степени детализации программных объектов и то, как они связаны с утечкой состояния, описаны далее в §3.1. 2.1 Транзакции: взаимодействие между сущностями Мы моделируем все взаимодействия между сущностями, используя понятие транзакций, которые имеют семантику, подобную IPC. Определение 1. Транзакция — это поток управления (и, возможно, данных) от одного программного объекта к другому. Объект-источник, или клиент, инициирует транзакцию, а объект-получатель, или сервер, получает и обрабатывает ее, возвращая управление источнику после завершения. Транзакции могут представлять собой вызовы процедур, системные вызовы, прерывания, сигналы, другие IPC и многое другое. Точное воплощение транзакции определяется тем, какие сущности в ней участвуют; например, вызов функции — это транзакция от одной функции к другой функции в том же потоке; системные вызовы — это транзакции из объекта пользовательского пространства в объект пространства ядра; IPC — это транзакция от одного процесса к другому. Транзакции имеют следующие явно определенные характеристики: • Если транзакция прерывается (например, вытесняется), она просто считается незавершенной до тех пор, пока не возобновится и не вернет управление. • Если транзакция никогда не завершается, например, вызов функции с бесконечным циклом, которая прослушивает сообщения, ее изменения не могут повлиять на будущие действия различных исходных сущностей; таким образом, это не имеет отношения к государственному разливу. • Если обработчик транзакции дает сбой, например, возвращая ошибку, это рассматривается так же, как завершенная успешная транзакция. • Если транзакция является асинхронной/неблокирующей, она рассматривается как две отдельные транзакции: начальная транзакция из источника в пункт назначения и вторая транзакция из пункта назначения обратно в источник как событие завершения. Нас в первую очередь интересуют кратковременные транзакции, которые оставляют долгосрочные изменения в объекте назначения, так что это повлияет на его будущее поведение. 2.2 Стабильность программных объектов При оценке утечки состояния нас интересует влияние отдельной транзакции на объект; таким образом, состояние объекта имеет значение только в определенные моменты: до и после транзакции, а не во время. Для определения этого состояния мы используем концепцию покоя. Учитывая, что коммуникация в нашей системной модели полностью основана на транзакциях, состояние покоя программного объекта определяется исключительно обработкой транзакций. Определение 2. Стабильность — это стабильное состояние объекта, когда у него нет незавершенных транзакций от внешних объектов. Сущность динамична, когда не находится в состоянии покоя. Это отличается от традиционных определений состояния покоя, которые обычно указывают, что данный объект должен быть полностью приостановлен, находиться в спящем режиме или отсутствовать во всех очередях выполнения ЦП [48, 53]. Другие определения покоя идут еще дальше, утверждая, что объект нельзя считать неподвижным, если какая-либо из его функций находится в стеке вызовов любого другого процесса [5, 32, 25, 7]. Стабильность, основанная на эпохе, использует промежуточный уровень для обеспечения доступа к данному объекту, гарантируя достижение состояния покоя, как только все другие объекты завершат взаимодействие с опосредованным объектом [49, 27]. Эти интерпретации состояния покоя слишком строги для наших нужд, поскольку из-за них почти каждый объект никогда не достигнет состояния покоя, особенно те, которые выполняются в фоновом режиме или никогда не завершаются, например, системные службы и ядро. Хотя такие определения заставляют многие типы событий предотвращать стабилизацию, например, вытеснение планировщика, наше определение упрощает это событие, чтобы оно происходило только после завершения транзакций между объектами. Это необходимо, поскольку, хотя такое событие, как вытеснение планировщика, может привести к тому, что объект станет неработоспособным, этот объект все еще может находиться в процессе обработки длительной транзакции, когда он заблокирован или иным образом исключен из очереди выполнения. 2.3 Состояние программного объекта Неформально, утечка состояния происходит, когда транзакция приводит к долгосрочным изменениям в целевом объекте. Прежде чем мы формально определим разлив состояния (§3), мы должны сначала определить, что мы считаем частью состояния данного программного объекта. Поскольку термин «программный объект» охватывает множество возможных воплощений (например, модули, процессы, потоки, классы), мы объединяем определение его состояния в сокращенный набор «основных состояний», которые являются общими для всех форм, за исключением состояний, специфичных для процесса или потока, таких как программный счетчик, стеки вызовов и функциональные кадры. . Определение 3. Состояние программного объекта, обозначаемое E, состоит из набора V программных переменных в пределах области действия объекта и значений этих переменных. Это определение ограничивает состояние объекта включением только информации в пределах области действия объекта, т. е. всего видимого в пределах логических границ объекта. Это справедливая, репрезентативная модель реальных объектов ОС, которые не могут контролировать внешнее состояние и получать к нему доступ из-за разрешений и политик безопасного сокрытия информации. Например, область действия модуля включает локальные переменные в функциях внутри этого модуля и глобальные переменные, к которым они обращаются. Область действия сущности процесса идентична области действия, определенной программой, выполняющейся в нем, которая включает все переменные программы, но исключает блок управления процессом и другое состояние ОС, внешнее по отношению к процессу. Для сущностей объекта класса все поля членов класса считаются входящими в область действия на протяжении всего существования этого объекта класса, в дополнение к любым локальным переменным и общедоступным статическим членам, доступным из текущей точки выполнения. Такое определение состояния программной сущности обязательно позволяет нам обрабатывать различные компоненты ОС единым образом, поддающимся формализации, статическому анализу и анализу времени выполнения. Еще одним преимуществом этого определения является его марковизм, т. е. исключение предшествующих входных данных, событий или потока управления из состояния объекта. Это позволяет легко анализировать объект: проверяется только текущее содержимое, предыдущее состояние игнорируется. Стационарное состояние объекта Когда объект находится в состоянии покоя, его состояние EQ становится уточнением состояния объекта E, исключая временные состояния. Формально временное состояние — это программная переменная, время жизни которой [47] не сохраняется после транзакции, которую в данный момент обрабатывает объект. Например, локальные переменные с автоматическим временем жизни являются временными состояниями, тогда как поля членов класса или глобальные переменные в процессе не являются временными. Только долговременные изменения, возникающие в результате транзакции, могут создать сложные проблемы для достижения вышеупомянутых вычислительных целей. Изменения временных состояний не важны и не имеют отношения к утечке состояний, поскольку они локальны для сущностей и не могут повлиять на сложные взаимозависимости и связи между сущностями. Определение 4. Состояние неактивного программного объекта EQ состоит из набора VQ, содержащего все невременные программные переменные в пределах области действия объекта и их значения. Напомним, что наше определение состояния покоя позволяет объектам достигать состояния покоя довольно часто — один раз после завершения каждой транзакции, учитывая, что другие транзакции еще не начались — и, таким образом, позволяет нам изолировать определенные состояния, измененные одной транзакцией. Это, в сочетании с устранением временных изменений, приводит к более точному анализу с значимыми результатами: утечка состояний действительно имеет значение. 3. Государственный разлив: формальное определение Теперь мы формально определим понятие государственного разлива и опишем условия, при которых он происходит. Когда объект-источник S инициирует транзакцию с объектом-получателем D, состояние D может претерпеть долговременное изменение во время обработки этой транзакции. Разлив состояния может быть явным, когда данные из S передаются и сохраняются в D, или неявным, при котором данные не передаются, но обработка транзакции вызывает изменение в D от имени S. Предыдущие работы решали проблемы, связанные с разливом состояния. , такие как анализ потока данных и отслеживание вредоносных данных в системном программном обеспечении [59, 29, 60] и в Android [8, 18]. В целом эти работы сосредоточены на отслеживании распространения данных по системе, часто в целях конфиденциальности, чтобы определить, какие данные к каким объектам могут попасть. Однако их не интересуют изменения в других объектах программного обеспечения и последующие эффекты, возникающие в результате упомянутого распространения данных, что, как мы обнаружили, является часто упускаемым из виду, но важным явлением. Осведомленность о перемещении данных — это шаг в правильном направлении, но мы утверждаем, что более полезно понять влияние этого перемещения данных, помимо проблем конфиденциальности (§8). from ence Формально, в S, сущность и состояние D разности, когда происходит спокойное разлив, было состоянием, вызванным после обработки S _ D, если существует транзакция.Транзакция является разной. Определение • • EQ EQ DD: 0: состояние покоя 5. Состояние состояния состояния SD _ D до того, как D произойдет завершение транзакции, если EQ D 6 = транзакция ED. из Q 0 , inS, который и Чтобы определить, является ли EQ D = ED Q 0 , необходимо сравнить невременные переменные в объекте D до и после данной транзакции (Определение 4). Поскольку состояние покоя объекта игнорирует внутренние действия (Определение 2), необходимо также игнорировать все изменения от этих внутренних действий в EQ D и ED Q 0 и сравнивать только те состояния, которые могут быть изменены посредством обработки этой транзакции объектом D. Определение 6. Два состояния покоя эквивалентны, если 8e 2 VQ0 | e 2 Mt, e 2 VQ ^ val Q(e) = valQ0 (e), где e — переменная в наборе (невременных) переменных объекта после транзакции, Mt — набор переменных, фактически измененных обработка транзакций, а val(e) — значение переменной e. Эта эквивалентность обозначается EQ = EQ0. В некоторых системах проверка эквивалентности состояний может оказаться непрактичной из-за размера или очень динамичной природы состояния объекта. Хотя нам еще предстоит столкнуться с такой сущностью, приближение проверки эквивалентности состояния может быть более ценным, чем прямое сравнение состояния сущности. Например, хорошей лакмусовой бумажкой для выявления утечки состояния может быть то, продолжает ли объект S успешно работать после того, как в состояние объекта D были внесены случайные изменения, не информируя S об этом изменении. Мы оставляем эти неточные приближения для будущих работ. Системный процесс Модуль/Класс Модуль/Класс Функция Функция Функция Функция Процесс Рис. 1. Детализация сущностей имеет вложенную иерархию; Разлив состояния по определению зависит от выбранной степени детализации. Показанный здесь выбор объекта на основе модуля/класса позволяет передавать состояние только в результате транзакций между этими объектами ( *); взаимодействия между более мелкими объектами (99K) не имеют значения. 3.1 Относительная степень детализации разлива состояний. Согласно приведенным выше определениям, разлив состояний относится как к пространственной детализации сущностей, так и к временной группировке транзакций между этими сущностями. Пространственная детализация сущностей. Поскольку транзакции по определению происходят между двумя сущностями, разлив состояний во многом зависит от пространственной детализации вовлеченных сущностей, т. е. от того, как определены их границы. Степень детализации сущностей варьируется от самого высокого уровня, когда весь компьютер рассматривается как единое целое, до самого низкого уровня, когда каждая отдельная функция или даже базовый блок рассматривается как мелкозернистая сущность. На самом высоком уровне детализации, когда весь компьютер представляет собой единое целое, передача состояния происходит с одного компьютера на другой посредством транзакций по сети; любое взаимодействие между приложениями внутри компьютера не имеет значения. Спускаясь на уровень ниже, если все многопроцессное приложение считалось единым объектом, то перелив состояния происходит из одного приложения в другое из-за транзакций между приложениями; любые взаимодействия внутри процессов или потоков этого приложения не имеют значения. На самом низком уровне, на котором каждая функция считается отдельной детальной сущностью, транзакции между функциями (вызовы функций) во всей системе могут вызвать утечку состояния, что делает утечку состояния повсеместной и неинтересной. Таким образом, как очень высокие, так и очень низкие уровни детализации объектов не являются ни полезными, ни подходящими для анализа, не говоря уже о том, что они непрактичны. Выбор степени детализации объекта для анализа разлива состояния зависит как от платформы, так и от цели. Например, если кто-то хочет определить препятствия для миграции процессов в Unix-подобной системе, каждый процесс должен быть отдельной сущностью, чтобы утечка состояния могла обнаруживаться в транзакциях за пределами адресного пространства процесса. Если вы хотите обновлять в реальном времени одну функцию изолированно, не беспокоясь о ее зависимостях от других функций, степень детализации объекта должна быть установлена ​​для одной функции, чтобы отслеживать разлив состояния между функциями. Для анализа системных сервисов Android (§6) более подходящей является детализация сущностей на основе классов, поскольку каждый сервис реализуется как ООП-класс. В этой работе мы выбираем золотую середину, выбирая умеренно грубую степень детализации объекта. Самая грубая степень детализации всего компьютера как единого целого уже изучалась и учитывалась в виде программных архитектур RESTful [23], используемых в веб-сервисах [39].*Теоретически принципы проектирования RESTful гарантируют, что транзакции между клиентом и 1 общедоступным классом SystemService 2 static int sCount ; 3 байта mConfig; 4 Список &lt;Обратный вызов&gt; mCallbacks; 5 int не связано; 6 7 public void addCallback (int id, 8 байт cf, обратный вызов cb) {9 int b = id; 10 Журнал. печать("id =" + б); 11 это. мКонфиг = ср; 12 это. mОбратные вызовы. добавить (КБ); 13 счет++; 14 } Листинг 1: Системная служба реализована как ООП-класс. Серверные системы являются автономными и не требуют хранения ранее существовавшего состояния на сервере, что предотвращает утечку состояния с самого начала. Мы выбираем более мелкую степень детализации, чем объекты всего компьютера, потому что разлив состояний в объектах среднего уровня более важен для целей системного исследования, на которые мы нацелены. Более того, этот выбор дает баланс значимых результатов, тогда как слишком мелкая или грубая степень детализации подвержена утечке состояний во всех взаимодействиях или без них соответственно. Временная детализация транзакций Помимо пространственного измерения детализации сущностей, разлив состояния также имеет временное измерение: детализация транзакции. Детализация временной транзакции определяет, сколько последовательных взаимодействий между двумя заданными объектами группируются в одну логическую транзакцию. Точная форма транзакции ортогональна ее временной детализации и определяется исключительно степенью детализации объекта, например, транзакция между двумя функциональными объектами должна быть вызовом функции. Хотя эта работа сосредоточена на анализе одной транзакции за раз, может оказаться полезным объединить несколько транзакций в одну. При анализе утечки состояния в общей процедуре из трех последовательных транзакций, например, при подключении и настройке обновлений от сенсорной службы, нет смысла определять, какие состояния теряются во время первых двух промежуточных транзакций. Фактически, выполнение этого в ходе инструментального анализа создаст ненужные накладные расходы, особенно если учесть, что разлив состояния необходимо анализировать только в отношении двух точек покоя (определение 5), а не отдельной транзакции. Таким образом, временная детализация транзакции является еще одним аспектом, который следует учитывать при понимании и обнаружении утечки состояния. 3.2 Простой пример передачи состояния Мы используем пример системной службы из листинга 1, чтобы конкретно проиллюстрировать, как приложения могут передавать состояние объектам системной службы. В этом примере служба реализована на объектно-ориентированном языке; таким образом, степень детализации его сущности соответствует классу, его границы включают все поля членов класса, а его общедоступные методы являются обработчиками транзакций/точками входа. Такие службы обычно создаются один раз при загрузке и никогда не завершаются, а срок их службы гораздо дольше, чем у приложений. Когда приложение инициирует транзакцию addCallback, оба параметра cf и cb вызывают явную утечку состояния путем изменения mConfig и mCallbacks соответственно, время жизни которых сохраняется после этой транзакции. Напротив, хотя параметр id передается в addCallback, он Клиент Клиент Клиент Клиент Клиент cb Клиент высокий уровень reg cb косвенное обращение общий общий низкий уровень msg ортог. ортог. Ресурс Ресурс Отправитель Ent 1 Ent 2 (a) (b) (c) (d) (a) гавань анимации Рисунок Косвенное направление два 2: состояние Общие представления разливаются по слоям при проектировании, служащем причиной шаблонов данных/команд; заявить несколько клиентов; причина, когда (b) состояние (c) преобразование мультиплексоров-диспетчеров разлива ( ). предотвратить утечку состояния, удерживая зарегистрированные обратные вызовы (cb) для доставки сообщения/события. (d) Сотрудничество между объектами приводит к разливу состояний, когда неортогональные состояния должны быть синхронизированы. не представляет собой утечку состояния, поскольку его время жизни является временным (локальным для функции) и заканчивается, когда транзакция возвращается. Поле sCount имеет время жизни, привязанное к времени жизни базового экземпляра среды выполнения (JVM), которое потенциально больше, чем у сущности SystemService; sCount является примером неявной утечки состояния, поскольку его значение изменяется в результате транзакции, несмотря на то, что оно не передается напрямую из приложения. Наконец, несвязанное поле фактически не изменяется транзакцией addCallback (несвязанное 2/Mt ); таким образом, хотя его значение могло быть изменено другим потоком во время транзакции, оно исключено из проверки эквивалентности спокойного состояния и не может способствовать утечке состояния.Формально состояние сущности D SystemService в несколько моментов выполнения выглядит следующим образом:

1. После загрузки службы, но до того, как произойдет какая-либо транзакция, D изначально находится в состоянии покоя, поэтому EQ D состоит из VD = sCount,
2. D mConfig становится динамическим mCallbacks в L9, со значениями и в L10 ⌦0, 0, имеет {?} дополнительный ↵ . временные переменные id, cf, cb, b .
3. После L13 D возвращается в состояние покоя, таким образом, EQ D 0 содержит VD Q 0 = sCount, mConfig, mCallbacks, соответствующие значения которых соответствуют 0, ED Q являются , Определение ⌦ 1, cf, {cb} 5 обусловливает ↵. что 6=4. Транзакция State addCallback Classification вызывает состояние Spill и высвобождает его из S_D. Вредные эффекты Теперь мы широко рассмотрим различные реальные операционные системы, чтобы продемонстрировать вездесущность и вредные последствия (выделены жирным шрифтом) разлива состояния в них. При этом мы предлагаем классификацию утечки состояний на основе различных шаблонов проектирования сущностей: уровни косвенности, мультиплексоры, диспетчеры и сотрудничество между сущностями. Хотя существуют и другие формы, они кратко отражают подавляющее большинство разливов состояний в объектах ОС и их роль в их возникновении. В §7 мы обсуждаем альтернативы этим конструкциям, исключающие разливы. 4.1 Передача состояния на уровнях косвенности Первая форма утечки состояния, изображенная на рисунке 2(a), происходит, когда клиент взаимодействует с уровнем косвенности для доступа к ресурсу более низкого уровня. Уровни косвенности могут представлять собой любой горизонтальный срез многоуровневого программного стека: например, приложение (клиент) может использовать API, предоставляемые библиотекой (уровень косвенности); системная служба (клиент) может получать доступ к устройствам ввода-вывода через драйвер ядра (уровень косвенности). Уровень косвенности преобразует клиентские запросы, выраженные на высоком уровне абстракции, в команды более низкого уровня, которые может понять базовый ресурс; при этом уровень косвенности сохраняет состояние, полученное от клиентского объекта, например, информацию о том, как клиент использует ресурс. Разработчики объектов уровня косвенности обязательно предпочитают хранить информацию, специфичную для клиента, внутри, чтобы (i) гарантировать соблюдение привилегий доступа и (ii) поддерживать представление о прогрессе клиента во время серии преобразований клиентских ресурсов. Общие абстракции: процессы и VFS Абстракция процесса — это уровень косвенного обращения, который позволяет непривилегированным пользовательским программам безопасно получать доступ к ЦП без понимания основного оборудования. Большинство монолитных ОС реализуют абстракцию процесса через уровень косвенности в ядре и поддерживают метаданные каждого процесса в виде единого списка, например, список структур задач ядра Linux. Пользовательская программа, работающая поверх и использующая абстракцию процесса, приведет к выходу состояния за ее пределы в переменные-члены структуры задачи и другие переменные в подсистеме управления процессами ядра. Такое разлитие состояния связано с решением проекта хранить всю информацию, связанную с процессами, в удобном централизованном месте, а также с необходимостью защитить такую ​​информацию от злонамеренного вмешательства в пользовательское пространство. Однако это делает миграцию процесса невозможной, поскольку необходимо отслеживать и извлекать состояния, передаваемые из процесса в другие объекты ОС (ядро и системные демоны), а это сложная и невыполнимая задача. Это признанная проблема, ранее называвшаяся «остаточными зависимостями» [34, 55], но она является симптомом разлива государства. Как обсуждается в следующем разделе, операционные системы с микроядером также имеют аналогичную утечку состояний, но внутри серверов пользовательского пространства, которые реализуют уровни косвенности, а не ядра. Уровень косвенности виртуальной файловой системы (VFS), присутствующий как в монолитных, так и в микроядерных ОС, обеспечивает простую файловую абстракцию для пользовательских процессов (клиентов) для доступа к низкоуровневым драйверам устройств (ресурсам). В качестве примера мы возьмем реализацию VFS в Linux и драйвер I2 C. Объект VFS сам по себе является уровнем косвенности, состояние которого включает в себя файл структуры, который управляет и хранит ссылки на базовое устройство и драйвер I2 C как часть своего частного элемента данных. Когда клиентский процесс выполняет транзакцию ioctl для файла устройства объекта VFS, ядро ​​направляет операцию с уровня VFS на реализацию ioctl соответствующего драйвера, i2cdev ioctl в случае I2 C. Поскольку она была инициирована VFS, это драйвер содержит ссылку на файловую структуру I2C VFS, и его функции могут напрямую изменять состояния VFS, например файловый режим, упреждающее чтение, мьютекс, права владения; другие операции, такие как чтение и запись, ведут себя аналогичным образом и изменяют другие состояния объекта VFS, например, смещение позиции файла. Это обманчивая форма неявного разлива состояния: уровень VFS, по-видимому, не изменяет свое собственное состояние и не сохраняет данные, передаваемые из пользовательского пространства, а скорее его состояние прозрачно изменяется объектом драйвера, скрытым под самим провайдером абстракции.Такой выбор конструкции был сделан из соображений удобства и эффективности: поскольку объекты VFS и драйвера используют одно адресное пространство ядра, разработчикам проще и быстрее напрямую обновлять элементы в файловой структуре VFS, используя общие ссылки, а не явную передачу сообщений. Аналогичный разброс состояний существует на VFS-серверах пользовательского пространства микроядерных операционных систем, таких как MINIX 3, Genode и других. Серверы пользовательского пространства с микроядром. Операционные системы на основе микроядра, такие как MINIX и seL4, переносят подавляющее большинство функций ОС на серверы пользовательского пространства в пользу очень небольшого ядра ядра. Эти серверы часто представляют собой уровни косвенного обращения, которые действуют как посредники между приложениями и микроядром, например, преобразуя вызовы API POSIX в специфичные для MINIX функции, которые может обрабатывать их микроядро. Такая программная архитектура приводит к утечке состояния, которая напрямую препятствует оперативному обновлению и горячей замене серверов микроядра, о чем свидетельствует утомительная, ситуативная попытка авторов MINIX включить динамические обновления в MINIX 3 [25]. Помимо уровней абстракции, серверы пользовательского пространства также соединяют уровни привилегий: серверы пользовательского пространства имеют больше привилегий, чем приложения, но меньше, чем ядро, например, они не могут выполнять переключение контекста или обработчики прерываний верхней половины. Введение различных уровней привилегий и абстракции — это выбор дизайна, в котором приоритет отдается модульности и минимизации размера ядра за счет высокой восприимчивости к утечке состояния. Например, планировщик пользовательского пространства MINIX 3 SCHED [50] представляет собой уровень косвенности, который находится между пользовательскими процессами и механизмом переключения контекста микроядра для управления политикой планирования системы. SCHED не имеет привилегий переключения контекста, поэтому он просто выбирает следующий целевой процесс для запуска и полагается на механизм переключения контекста ядра (sys schedctl). Системный вызов sys schedctl копирует параметры, относящиеся к процессу, в список структурных процессов ядра — яркий пример утечки состояния — перед фактическим запуском переключения контекста. Распространенные состояния включают в себя флаги планирования целевого процесса, конечную точку, родительскую конечную точку, приоритет, квант временного интервала, маску привязки ЦП, бит постановки в очередь расписания и многое другое. Та же самая структура механизма пространства ядра политики пользовательского пространства используется для многих других серверов MINIX 3, таких как менеджер процессов (§4.2), виртуальная файловая система, менеджер памяти и сервер реинкарнации, все из которых вызывают аналогичные формы утечки состояния. . Для краткости мы опускаем их детали, но такое разлитие состояния является прямым препятствием для реализации оперативного обновления, горячей замены и виртуализации указанных серверов пользовательского пространства. 4.2 Разлив состояния при мультиплексировании Вторая форма разлива состояния обычно возникает, когда объект действует как мультиплексор, который позволяет множеству клиентов получить доступ к одному базовому ресурсу посредством его совместного использования во времени или пространстве. Как показано на рисунке 2(b), объект мультиплексора вызывает утечку состояния, сохраняя состояния, которые соответствуют индивидуальному взаимодействию каждого клиента с ресурсом. Эта форма утечки состояния обычно возникает по необходимости, поскольку объект мультиплексирования должен поддерживать контекстные данные о своих пользователях, чтобы правильно разделять свой ресурс и управлять им. Например, драйвер устройства содержит представление об использовании каждым процессом своего периферийного оборудования; подсистема виртуальной памяти содержит сопоставления и другие детали распределения для мультиплексного доступа приложений к физической памяти. Управление процессами Объекты управления процессами (PM) временно мультиплексируют доступ к базовому ЦП (ресурсу) между несколькими пользовательскими процессами (клиентами). Они поддерживают метаданные о каждом клиентском процессе, чтобы отслеживать и контролировать их, например, решая, когда и что запускать. Эти метаданные, специфичные для процесса, являются ярким примером утечки состояния, которая существует во многих конструкциях ОС и отрицательно влияет на приведенные ниже вычислительные цели. Например, когда один процесс создает другой через разветвление, мультиплексор PM создает набор структур данных для представления состояния этого нового процесса, что является формой неявного разлива состояния. В монолитных ОС, таких как Linux, эта утечка происходит из процесса в подсистему PM ядра; в микроядерных ОС, таких как MINIX 3, эта утечка происходит из процесса на PM-сервер пользовательского пространства.Помимо создания процесса, другие действия PM вызывают утечку состояния; когда процессы выполняются и взаимодействуют с периферийными устройствами и другими объектами, объекты PM на серверах пользовательского пространства или в ядре должны соответствующим образом обновлять свои таблицы процессов, чтобы отразить новое состояние процесса. Например, когда процесс обращается к устройству ввода-вывода, вызывая системный вызов драйвера read(), драйвер устройства может заблокировать этот процесс, установив флаг в своей записи таблицы процессов во время выборки запрошенных данных, вызывая запутанное вытекание состояния из устройства. клиентский процесс к мультиплексору PM через драйвер. Распространение состояния в мультиплексорах не только вызывает вышеупомянутую проблему остаточных зависимостей, которая затрудняет миграцию процессов (раздел 4.1), но также нарушает гарантии изоляции ошибок, неразрывно связывая состояния своих клиентских объектов в единый объект. вызывая разделение судьбы. То есть, если один процесс вызывает повреждение или сбой на сервере PM, это также повлияет на другие процессы. В связи с этим отказоустойчивость в мультиплексорах невозможна в условиях утечки состояния: восстановление вышедшего из строя экземпляра сервера от имени одного клиентского процесса может быть успешным, но это фатально нарушит работу других клиентов, использующих этот сервер, из-за неожиданного отсутствия или изменение состояний на стороне сервера [11]. Фактически, это справедливо для большинства уровней косвенности и мультиплексоров, а не только для объектов PM. Архитектурная философия монолитных и микроядерных ОС может потребовать такого разлива состояний, но некоторые экспериментальные ОС уменьшают его с помощью уникальных подходов. Genode [1] использует иерархический метод управления проектами, при котором объект, создающий процесс, сохраняет метаданные и контролирует этот новый процесс. Это действительно уменьшает степень распространения состояния на сущности PM, но не полностью отделяет создателя или созданный им процесс от указанных сущностей PM. Управление окнами Хотя вышеупомянутые мультиплексоры PM являются временными, системы управления окнами (WM) представляют собой пространственные мультиплексоры графических ресурсов, таких как кадровые буферы. Клиентские приложения создают содержимое своего представления и манипулируют им, отправляя запросы, содержащие состояние, специфичное для приложения, мультиплексору WM, который назначает этому приложению область ресурса экрана/кадрового буфера. Состояние, хранящееся в объекте WM при обработке запроса приложения, представляет собой передачу состояния от приложения к объекту WM. Объекты WM также содержат явную утечку состояния при получении данных конфигурации и содержимого окон от приложений, которые они сохраняют напрямую, вместо того, чтобы позволить приложениям контролировать свои собственные данные. Система X window [45], хотя и спроектирована как слабосвязанные модули, допускает такое разброс состояний между различными компонентами мультиплексора. Одним из примеров является X-сервер, объект, который мультиплексирует ресурсы локальной клавиатуры, мыши и дисплея между многими клиентскими приложениями, сохраняя специфичную для клиента информацию в объекте сервера, когда данный клиент запрашивает создание окна или отображение контента. Другие действия, обрабатываемые X-сервером, включают централизованное переоформление окон и кэширование закадровой графики (для контекстных меню и временных всплывающих окон), чтобы избежать взаимодействия клиент-сервер; эти действия требуют, чтобы состояния запросов приложений хранились в локальном хранилище объекта X-сервера, что неизбежно приводит к утечке состояния из приложений в мультиплексор X-сервера. Другим компонентом X, вызывающим утечку состояния, является его оконный менеджер, например, Compiz, KWin, мультиплексор, который поддерживает Z-глубину и другие данные макета от имени каждого окна приложения, чтобы правильно позиционировать окна относительно друг друга. Nitpicker, нетипичный мультиплексор WM в Genode [21], заставляет каждого клиента брать на себя ответственность за свои частные представления и буферы в попытке улучшить межклиентскую безопасность. Затем Nitpicker обращается к этим клиентским буферам через сопоставления общей памяти только по явному запросу клиента. Это уменьшает утечку состояния, позволяя клиентам выделять и управлять своими собственными буферами представлений, но по-прежнему сохраняет некоторые раскрытые состояния в форме метаданных для каждого клиента: информацию о слоях глубины, миниатюры каждого представления, сочетания клавиш и т. д. В мультиплексорах WM, как и в случае с В мультиплексорах PM, описанных выше, утечка состояния нарушает изоляцию неисправностей, что делает горячую замену и обновление в реальном времени чрезвычайно трудными, поскольку отдельные объекты (например, клиент и X-сервер) не могут обновляться изолированно или заменяться независимо друг от друга.Атомарное обновление нескольких отдельных объектов является требованием согласованности — многие работы по обновлению в режиме реального времени [7, 25, 27, 48, 5] посвящают большую часть своих усилий определению состояний покоя и аккомодации, распределенных между несколькими объектами — но на практике это нецелесообразно. возможно для оконных систем со многими тесно связанными компонентами. Распространение состояния в WM не существенно усложняет миграцию процесса, поскольку объекту WM, скорее всего, потребуется реконструировать графическое окно приложения и отображаемый контент на новой целевой машине после миграции. С точки зрения безопасности утечка состояния в мультиплексорах WM особенно вредна, поскольку частный контент может быть раскрыт другим клиентским окнам через общую среду мультиплексора. Из-за пропущенных состояний, которые совместно хранятся в объекте мультиплексора, вредоносные клиентские приложения X могут быть способны вмешиваться в другие окна, вводить ложные нажатия клавиш или использовать их для целей кейлоггера или красть содержимое общих буферов (например, данные буфера обмена) и многое другое. [4]. Созданный запрос от X-клиента может даже привести к тому, что X-сервер перезапишет произвольную память оконных буферов, размещенную в его объекте мультиплексора [4], что приведет к выполнению произвольного кода или отказу в обслуживании для клиентов, зависящих от этих буферов. 4.3 Передача состояния в диспетчерах Третья форма утечки состояния возникает в диспетчерах, которые позволяют клиентским объектам регистрировать обратные вызовы для получения событий или сообщений от отправляющего объекта, как показано на рисунке 2(c). Например, приложение, которому необходимо дождаться определенного события, может зарегистрировать обратный вызов с демоном или ядром, которое получает событие; это очень распространено в моделях программирования, управляемых событиями. Диспетчеры обязательно вызывают утечку состояния, удерживая предоставленные клиентом ссылки на обратный вызов, чтобы правильно маршрутизировать связь между объектами. Фактически, это часто появляется как подкомпонент других шаблонов; например, X-сервер (клиент) регистрирует обратные вызовы в драйвере ввода-вывода ядра (мультиплексоре) для получения событий HID. Во многих реализациях IPC диспетчеры вызывают утечку состояния; например, объекты диспетчера IPC System V в ядре поддерживают ключи разрешения ipc, сопоставленные с идентификаторами внешних ссылок, и синхронизируют векторы сообщений и байты состояния структуры задач IPC. Доменные сокеты Unix, подсистемы inotify и d-bus схожи. Хотя сигналы не обязательно требуют регистрации обратного вызова, диспетчер сигналов ядра Linux может вызвать утечку состояния, когда, например, маска блокировки сигнала или массив сигнатур изменяются в дескрипторе задачи данного процесса или блокируется сигнальный процесс. Наконец, мьютексы и функции блокировки также могут способствовать утечке состояния; например, реализация семафора в MINIX 3 представляет собой объект-диспетчер, который реализует мьютекс путем добавления ссылок на ожидающие процессы в таблицу процессов мультиплексора PM, так что он может отправлять события освобождения мьютекса этим ожидающим процессам. Эти ссылки, хотя и необходимы, но представляют собой утечку состояния, когда процесс использует семафоры. В системе Swift [14] объект нижнего уровня (отправитель) может вызывать процедуру в объекте более высокого уровня (клиент), используя механизм upcall, предлагаемый промежуточным объектом (диспетчером). Распространение состояния происходит потому, что объект более высокого уровня должен вызвать диспетчер, чтобы зарегистрироваться, чтобы будущие вызовы могли доставить правильный контекст выполнения для объекта более высокого уровня. Более того, поскольку ключевые процедуры на нижних уровнях системы Swift полагаются на правильную реализацию процедур более высокого уровня (а-ля полиморфизм), эти процедуры имеют тенденцию получать доступ к общим данным через «вертикальную полосу», охватывающую несколько уровней. Автор Swift осознал эту проблему и попытался ее исправить, предписав, чтобы все общие данные, связанные с клиентом, были разблокированы и согласованы перед вызовом; однако эту гарантию было трудно реализовать. Любые данные в этой вертикальной полосе, не защищенные мьютексами, способствуют утечке состояния, что приводит к взаимозависимой связи между многоуровневыми объектами, что является прямой проблемой для изоляции ошибок, отказоустойчивости и удобства обслуживания. Фактически, эта проблема и другие симптомы утечки состояния в механизмах вызова, такие как непредсказуемые опасности потока управления, являются барьерами для надлежащей безопасности; следовательно, диспетчеры, поддерживающие произвольные вызовы в пользовательское пространство, никогда не были приняты в основное ядро ​​Linux [9, 2]. 4. Разлив состояний из-за сотрудничества между организациями Наконец, четвертая форма разлива состояний возникает, когда несколько объектов взаимодействуют друг с другом, чтобы гарантировать правильность и последовательность в своем взгляде на ОС, как показано на рисунке 2(d). Это связано с желанием добиться разделения задач, при котором сложная функция ОС, такая как создание процессов, разбивается на ряд более мелких обязанностей, каждая из которых назначается конкретным объектам (обычно системным службам или процессам-демонам). На бумаге обязанности и состояния каждого объекта ортогональны, что приводит к более модульной архитектуре программного обеспечения. статический анализ в цикле совместной обратной связи для точного обнаружения разлива состояний. тура; однако в действительности каждая сущность имеет общие состояния, которые либо являются общими с другими сущностями, либо зависят от них. Поэтому общая информация (не обязательно идентичные реплики) должна быть синхронизирована, что приводит к утечке состояния, что ухудшает удобство обслуживания, оперативное обновление и многое другое. Например, MINIX 3 разделяет такие сложные задачи ОС между несколькими серверами пользовательского пространства, каждый из которых поддерживает свою собственную версию ключевых структур данных, например, таблиц процессов, для выполнения своих обязанностей. Когда приложение в MINIX 3 желает установить свой uid или gid, сервер PM первым получает и обрабатывает этот вызов. Однако обязанности PM не распространяются на файловую систему, поэтому он должен попросить сервер VFS завершить связанные с файлами аспекты вызова, а затем перейти к сотрудничеству с сервером управления памятью (MM), SCHED и так далее; каждый сервер имеет свою версию общих структур данных, которые необходимо синхронизировать. Этот шаблон встречается во многих других вызовах POSIX, например, exec, fork, функциях виртуальной памяти, а также в других микроядерных ОС и Android. Эта форма утечки состояния особенно коварна, поскольку, хотя пользователь может предвидеть утечку состояния в целевой транзакции (сервере PM), утечка состояния, вызванная синхронизацией, в других объектах (VFS, планировщик, MM) полностью скрыта.
4. STATE S PY: автоматический анализ утечки состояния. Чтобы обнаружить и проанализировать утечку состояния в реальных системах, мы разрабатываем и внедряем STATES PY, набор инструментов, который автоматизирует обнаружение утечки состояния и помогает разработчикам понять условия. при которых в их субъектах может произойти разлив государства. Разработчики просто подключают STATE-S PY к существующему объекту, работающему в реальной ОС, и позволяют ему выполняться в обычном режиме (в идеале с различными входными данными), после чего автоматически выводятся результаты, содержащие все обнаруженные случаи утечки состояния и действия. это их вызвало. STATE S PY также принимает в качестве входных данных исходный код объекта, чтобы ограничить объем анализа и исключить ложные результаты. Как показано на рисунке 3, компонент анализа времени выполнения STATE S PY работает совместно с компонентом статического анализа для генерации результатов утечки состояния. Наш подход связан с конколик-тестированием [46] тем, что он сочетает в себе статический анализ, подобный символическому исполнению, с анализом времени выполнения, но инвертирует конколическое тестирование, поскольку наши результаты поступают непосредственно из компонента анализа времени выполнения. Поскольку concolic-тестирование начинается с единственной реальной трассировки выполнения, оно может непреднамеренно исключить некоторые потенциальные пути выполнения, основанные на этих начальных начальных значениях времени выполнения, что приведет к плохому охвату. Однако, поскольку статический анализ STATE SPY консервативно исключает нерелевантные состояния, а не пути, его результаты во время выполнения не могут пропустить экземпляры утечки состояния в любом пути кода Java. В следующих разделах описываются проблемы разработки совместного анализа и реализации самой программы STATE SPY. Мы реализовали анализ времени выполнения и статический анализ STATES PY в 1643 и 2648 строках Java-кода соответственно. Мы стремимся, насколько это возможно, сохранять независимость нашего проекта от ОС; однако, поскольку STATE SPY в настоящее время нацелен на системные службы Android (§6), некоторые аспекты специфичны для Java. Инструмент для собственных языков неуправляемых систем (например, C/C++) легко реализовать с использованием методов, аналогичных описанным ниже. 5.1 Проблемы анализа утечки состояний При разработке инструмента анализа утечки состояний необходимо решить четыре основные задачи: обнаружение состояния покоя в объекте, захват состояний объекта со значимым контекстом, различение этих состояний и фильтрация нерелевантных результатов. Первые три проблемы решаются с помощью компонента анализа времени выполнения STATE SPY, последняя — с помощью статического анализа. Дополнительная проблема связана с недостатками, присущими анализу времени выполнения и статическому анализу при попытке совместного использования обоих методов; это рассматривается в §5.4. Обнаружение покоя В общем случае трудно определить, когда объект находится в состоянии покоя, поскольку состояние покоя часто определяется условиями, специфичными для окружающей среды. Однако наше определение состояния покоя, основанное на транзакциях, упрощает эту задачу: нам нужно только обнаруживать транзакции, входящие в объект, и время завершения этих обработчиков. В Android это относительно просто, поскольку транзакции между объектами имеют четкую точку входа и выхода из-за строгого характера протокола Binder IPC. Таким образом, STATE S PY может просто отслеживать выполнение объекта, приостанавливая потоки в начале указанного метода Binder (например, onTransact), создавая период покоя. В других системах STATE SPY может принимать определенные разработчиком точки входа и выхода, чтобы определить, что представляет собой транзакция. Регистрация состояния программного объекта. Регистрация состояния произвольного программного объекта остается сложной проблемой, которая вращается вокруг компромисса между универсальностью и точностью. Подходы к захвату состояния делятся на два основных раздела: (i) захват основного содержимого памяти объекта в среде выполнения или (ii) захват содержимого его состояния на уровне языка. Первый подход (i) является общим — никакой поддержки, понимания или модификации на уровне языка не требуется — но он требует устранения разрыва для восстановления семантических знаний об этом захваченном содержимом памяти, что остается открытой проблемой в области криминалистики. Например, если бы ядро ​​прозрачно захватило адресное пространство пользовательского процесса, оно не знало бы, какое содержимое памяти представляет какие состояния. Таким образом, хотя этот подход может поддерживать произвольные программные объекты, классификация состояний объектов (или их базовой памяти) как временных, доступных для модификации или любых других характеристик была бы неосуществима, что не позволило бы нам определить, способствуют ли они утечке состояний.Последний подход (ii) менее общий — он работает только для данного языка или среды выполнения — но сохраняет контекстные метаданные, такие как дескрипторы переменных и информацию о типах. Значимый контекст жизненно важен для понимания и классификации состояний в сущности, чтобы точно обнаружить утечку состояний. Поэтому мы применяем подход на уровне языка, который позволяет избежать разрыва между значениями состояний и их семантическими значениями, позволяя ГОСУДАРСТВЕННОМУ ШПИОНУ сохранять состояния в их исходной форме для анализа. О трудностях разработки подходов к захвату состояния на уровне языка лучше всего свидетельствуют следующие недостатки существующих подходов. • Статический анализ не всегда может детерминированно гарантировать, изменится ли данное состояние, а только то, что оно потенциально может измениться. Кроме того, его неспособность точно разрешать абстрактные типы или методы препятствует полному обходу всех возможных путей выполнения. • Запись и воспроизведение, как правило, проще реализовать, чем захват состояния на основе контрольных точек, но при этом невозможно проверить фактическое содержимое измененных состояний, а только действия, которые вызвали эти изменения. • Сериализация требует специальной поддержки со стороны языка для каждого типа, которую не предлагает большинство устаревших систем, и ее невозможно реализовать в общем виде. • Инструментирование среды выполнения требует изменения среды выполнения для предоставления информации о состоянии — невероятно сложный подход, который рискует нарушить поведение объекта или даже нарушить его корректность. Кроме того, любой исполняемый код, скомпилированный в собственные или машинные двоичные файлы, будет обходить среду выполнения, что делает невозможным вставку в этот код даже при наличии соответствующих перехватчиков. Хотя плагины во время выполнения допускают такой ненадежный самоанализ, во многих реализациях во время выполнения отсутствует поддержка стандартизированных функций и перехватчиков, на которые полагаются эти плагины, например, среда выполнения Android ART/Dalvik. Чтобы преодолеть эти проблемы, наша основная идея состоит в том, чтобы использовать структуры отладки, которые уже существуют в среде выполнения или среде выполнения, чтобы неинвазивно фиксировать состояние объекта (§5.2). Использование расширений отладки — это гибкий метод, применимый практически ко всем другим платформам и системам, обеспечивающий доступ к состояниям объектов с полной контекстной информацией, необходимой для анализа утечки состояний. Различие захваченных состояний Чтобы определить, привела ли транзакция к утечке состояния, необходимо различать состояние покоя объекта до и после этой транзакции. Это сложно, поскольку каждое состояние необходимо сравнивать в соответствии с лежащими в его основе деталями, например, типом и размером переменной. По сути, это требует полного семантического понимания каждого состояния, поскольку сравнение списка целых чисел отличается от сравнения двух пользовательских структур. К счастью, правильное различение состояний идет рука об руку с правильным захватом состояний, описанных выше; то есть использование сред отладки также предоставляет STATE SPY достаточные метаданные для проведения правильного сравнения состояний. В дополнение к проблеме правильного семантического сравнения состояний необходимо решить проблему представления захваченных состояний таким образом, чтобы поддерживать произвольную структуру, циклические ссылки и иерархические отношения между состояниями. Для этого STATE SPY строит древовидный циклический орграф, который отражает структуру состояний объекта в работающем объекте (раздел 5.2). При правильном структурном представлении и семантическом понимании состояний сущностей мы можем применить существующие алгоритмы сравнения деревьев, чтобы определить, какие состояния изменились во время транзакции, т. е. случаи утечки состояний. Фильтрация результатов Трудно представить только соответствующие случаи разливов в штатах, поскольку не существует достоверных данных о том, что на самом деле представляет собой разлив в штате, кроме определения эксперта-разработчика. Анализ времени выполнения не может различать состояния, которые были изменены в результате прямой транзакции, и состояния, которые изменились во время транзакции (например, фоновыми потоками). Это условие мы называем достижимостью модификации, выведенной из определения 5. Это приводит к потенциальное обилие ложноположительных результатов, т. е. когда состояние изменилось во время транзакции, но не из-за этой транзакции. Чтобы исправить это, мы полагаемся на статический анализ для оценки достижимости модификации всех состояний объекта, описанный в §5.3. 5. Проект анализа во время выполнения Компонент анализа во время выполнения STATE S PY обнаруживает утечку состояния в соответствии с определением 5: состояние объекта фиксируется дважды, в точках покоя до и после транзакции, а затем дифференцируется для выявления потерянных состояний. Чтобы решить первые три проблемы, описанные выше, мы используем структуры отладки на уровне языка, которые могут определить, находится ли объект в состоянии покоя, ненавязчиво получить доступ к его состоянию и получить полные контекстные метаданные, чтобы получить семантическое понимание всех состояний объекта. Несмотря на присущую языковую специфику, мы избегаем функций, специфичных для среды — точки наблюдения не поддерживаются многими JVM, такими как ART/Dalvik — и стремимся сохранить наши ключевые концепции дизайна независимыми от языка, чтобы основные идеи были переносимыми, даже если реализации нет. Использование платформ отладки действительно имеет много преимуществ: • Все среды выполнения управляемых языков предлагают надежные расширения отладки, даже те, которые не поддерживают инструментарий или специализированные плагины; • Самоанализ с помощью средств отладки безопасен и не может поставить под угрозу правильность объекта или среды выполнения; • Поддержка отладки также доступна в средах выполнения без базовой среды выполнения или уровня виртуализации, например, в собственных процессах C/C++. Компонент анализа времени выполнения STATE SPY спроектирован как автономное приложение, которое запускается в среде выполнения хоста, отдельной от целевой среды выполнения, которая содержит анализируемый объект. Он основан на стандартных приемах отладчика, например, точках останова, проверке переменных, оценке выражений, чтобы приостановить целевую среду выполнения и вызвать состояние покоя перед доступом к содержимому состояния внутри. В нашей реализации анализа времени выполнения STATE S PY, специфичной для Java, интересующий программный объект выполняется в целевой среде выполнения JVM и состоит из объекта Java, экземпляра класса Java. Этот класс содержит методы обработки транзакций, которые изменяют состояния объекта, т. е. его поля-члены.Полная процедура, выполняемая инструментом среды выполнения:
5. Подключитесь к целевому процессу JVM и дождитесь стабилизации, установив точки останова при входе в каждый метод обработчика транзакции в объекте сущности.
6. При достижении точки останова на входе вызовите состояние покоя, приостановив потоки в целевой JVM. Затем запишите полное состояние объекта сущности в JVM хоста как EQ.
7. Установите точки останова в точках выхода текущего метода обработчика транзакции и возобновите потоки в целевой JVM.
8. При достижении точки останова на выходе снова вызовите состояние покоя, приостановив потоки целевой JVM. Зафиксируйте полное состояние объекта сущности как EQ0.
9. Отключите точки останова на выходе, повторно включите все точки останова на входе из шага 1 и возобновите потоки в целевой JVM.
10. Наконец, в главной JVM вычислите разницу в состоянии объекта до и после транзакции, EQ0 EQ, которая представляет собой утечку состояния, вызванную этой транзакцией. Однако даже при наличии платформ отладки захват полного состояния объекта класса сущности оказывается на удивление нетривиальной задачей. Мы не можем просто создать неглубокую копию или продублировать ссылки на состояние объекта внутри целевой JVM по двум причинам: (i) это приведет к перезаписи значений состояния до транзакции значениями после транзакции, поскольку два объекта являются одним и тем же и не могут сосуществовать; (ii) это нарушает нашу гарантию того, что мы не будем навязчиво изменять внутренние состояния целевой JVM. Вместо этого STATE SPY должен полностью исследовать сложный граф объекта сущности, начиная с определения класса верхнего уровня и рекурсивно прослеживая все ссылки на его поля до других экземпляров подкласса. Это исследование в глубину продолжается до тех пор, пока не будет достигнут примитивный объект нижнего уровня, после чего в памяти инструмента (хост-JVM) генерируется пользовательское древовидное представление графа объекта, которое отражает как ссылки на объекты, так и значения примитивов. объекта в целевой JVM. Такое древовидное представление имеет несколько преимуществ: оно соответствует интуиции разработчиков и совместимо с существующими алгоритмами дифференцирования и инструментами визуализации. Чтобы сократить время выполнения и объем памяти, STATES PY выбирает, какие ссылки на объекты или примитивные значения включать или исключать. Это достигается с помощью белого списка достижимости изменений из компонента статического анализа, но разработчики также могут настроить его вручную. Кроме того, STATE S PY знает тип объекта, семантическое значение и любые ссылки на него; это позволяет создавать деревья с уникально идентифицируемыми узлами, поддерживая иерархическое сдерживание и циклические ссылки, избегая при этом избыточного захвата уже встреченных узлов. 5.3. Структура статического анализа Как упоминалось ранее, основным недостатком анализа времени выполнения, описанного выше, является его неспособность различать состояния, которые изменились во время транзакции, и состояния, которые изменились как прямой результат этой транзакции, что приводит к потенциальным ложным срабатываниям. Следовательно, единственной целью нашего статического анализа является устранение этой двусмысленности, т. е. решение проблемы достижимости модификации. Статический анализ STATES PY создает консервативный белый список, включающий только те состояния, которые доступны или могут быть изменены. Эта проблема напоминает отслеживание искажений и анализ потоков данных (см. § 8), но решает дополнительный сложный случай неявного утечки состояния, который не обнаруживается при анализе информационных потоков и лучше решается с помощью таких методов, как символическое выполнение. Однако требования потока данных к идентификации источника/приемника и символическому представлению значений объекта на основе терминов не подходят для определения достижимости модификации, поэтому мы разрабатываем собственный алгоритм. STATES Алгоритм статического анализа PY рекурсивно исследует каждую инструкцию каждого метода, доступного из точки входа каждого метода обработчика транзакций в целевой сущности. Начиная с исходного набора интересующих переменных (VOI), содержащего непостоянные поля-члены целевой сущности, алгоритм распространяет VOI и переменные, которые были изменены или присвоены псевдонимы, при каждом вызове метода и обратно. Мы используем структуру Soot [54] для анализа Jimple, простого промежуточного представления Java, что означает, что переменные могут быть изменены только тогда, когда они находятся в левой части оператора присваивания, а VOI может быть псевдонимом только тогда, когда находится в левой части. оператора присваивания. По сути, этот метод представляет собой форму прямого разделения программы [57], при котором выбираются и анализируются только инструкции в этом фрагменте, т. е. те, которые способны изменить любую VOI. Однако прямое нарезка страдает от взрыва пространства поиска; Чтобы смягчить это, мы отслеживаем и распространяем только модификацию или псевдонимы VOI, а не распространение всех переменных. Чтобы еще больше сократить время анализа, мы кэшируем переменные, которые изменяются и имеют псевдонимы каждым методом; ради возможности повторного использования они выражаются в виде строковых литералов (например, this, return, param#) вместо фактических идентификаторов переменных. Затем, в следующий раз, когда встретится кэшированный метод, мы сразу узнаем, будут ли базовый объект, возвращаемое значение или значения параметров изменены или псевдонимы этим методом.Полный алгоритм, приведенный в [10], выводит список доступных для модификации полей в целевой сущности для каждой транзакции, который передается в инструмент анализа во время выполнения для уменьшения ложных срабатываний. 5.4 Устранение разрыва с помощью петли обратной связи Как упоминалось ранее, мы устанавливаем петлю обратной связи (рис. 3) между компонентами среды выполнения и статического анализа STATES PY для устранения недостатков каждого из них. Однако это приводит к возникновению циклической зависимости: статический анализ сам по себе не может полностью изучить все методы из-за неоднозначных объявленных типов или нескольких возможных реализаций для данного вызова метода, поэтому для точного разрешения ему нужна информация о разрешении типов из компонента времени выполнения. эти двусмысленности; Для анализа во время выполнения требуются запросы разрешения и белые списки из статического компонента. Однако анализ времени выполнения может разрешать только типы, с которыми он сталкивается в реальном выполнении, но не знает, какие пути выполнения исследовать, пока статический компонент не запросит сопоставления для отсутствующих типов. Чтобы устранить эту ловушку 22, мы разрушаем циклическую зависимость, синтезируя искусственные тестовые примеры, которые заставляют инструмент среды выполнения проходить путь выполнения, содержащий разрешение типа среды выполнения абстрактного объявленного типа, о котором идет речь, которое затем возвращается в статический анализ. компонент. Мы эффективно загружаем инструмент статического анализа с несколькими сопоставлениями разрешения типов и инструмент среды выполнения с простым полным белым списком, а затем итеративно увеличиваем набор сопоставлений типов, одновременно уменьшая белый список в соответствии с достижимостью модификации. Поскольку все данные обратной связи, передаваемые между компонентами, не изменяются при выполнении анализа, мы постоянно сохраняем эту информацию для использования в будущем. 5.5 Проверка ограничений STATE S PY В настоящее время наша реализация STATES PY стремится к полноте, а не к надежности, но не гарантирует ни того, ни другого. Для ясности, STATE SPY считается завершенным, если он не пропускает никаких результатов, которые на самом деле являются разливом состояния (т. е. нет ложноотрицательных результатов), и корректным, если все возвращаемые результаты действительно являются истинными экземплярами разлива состояния (т. е. нет ложных срабатываний). Мы стремимся исключить ложноотрицательные результаты и при этом свести к минимуму ложноположительные результаты. В этом случае ложное срабатывание — это измененное состояние, идентифицированное нашим инструментом как утечка состояния, которое на самом деле не является истинным утечкой состояния, тогда как ложноотрицательное значение — это реальный случай утечки состояния, который наш инструмент пропустил. Мы применили STATE SPY к случайной выборке из 60 транзакций в системных службах Android и вручную проверили результаты. Мы обнаружили, что STATE S PY достигает уровня ложноположительных результатов менее 11% по этим 60 транзакциям, большая часть которых связана с нашей незрелой поддержкой собственных методов. Без статического анализа только анализ времени выполнения приводит к тому, что уровень ложных срабатываний для некоторых сервисов значительно превышает 60%, что подчеркивает необходимость ограничения достижимости модификации. Из-за огромного количества транзакций в Android и отсутствия достоверной информации мы не можем точно оценить уровень ложноотрицательных результатов STATE SPY; однако тематическое исследование в §6.4 показывает, что иногда могут возникать ложноотрицательные результаты. Как упоминалось выше, мы консервативно включаем состояние в белый список, если статический анализ не может определить, доступно ли его изменение по таким причинам, как динамическая отправка, неотслеживаемый собственный код или непрозрачные ссылки на внешние типы. Основываясь на нашем опыте, мы считаем, что С точки зрения разработчика, определить легитимность результата государственной утечки относительно легко, тогда как обнаружить результаты государственной утечки, которые были ошибочно пропущены STATE SPY (ложноотрицательные результаты), практически невозможно. Таким образом, ложноположительные результаты менее вредны, чем ложноотрицательные, поэтому мы отдаем приоритет полноте.
11.

## Разлив состояний в Android. В то время как в §4 изучаются и классифицируются разливы состояний в самых разных объектах ОС, в этом разделе подробно рассматриваются системные службы Android под руководством STATE S PY. Наши результаты показывают, что утечка состояния — это сложная и широко распространенная проблема, которая пронизывает подавляющее большинство системных служб Android и наносит ущерб вышеупомянутым вычислительным целям. 6.1 Экспериментальная методология До сих пор мы представляли примеры утечки состояния для каждого объекта, но теперь мы опишем утечку состояния для каждой транзакции, поскольку STATE S PY способен отслеживать отдельные транзакции. Результаты, ориентированные на транзакции, более полезны для разработчиков, стремящихся изолировать причины утечки состояния в своих объектах; знание того, что данная организация является источником утечки состояния, менее точно, чем знание того, какая транзакция ее вызвала. Чтобы получить большую репрезентативную совокупность транзакций для анализа, мы загрузили 150 Android-приложений из различных топ-категорий в Google Play. 1 1 2 5-

0 5 0 0 7 9

- - --+ 1 1 4 4 9 9 Разных экземпляров утечки состояния на одну заглушку службы Рис. 4. Гистограмма, показывающая, сколько отдельных экземпляров утечки состояния происходит в пределах данной заглушки службы. В одной системной службе может существовать несколько заглушек, но обычно только одна или две. хранили и использовали инструмент автоматизации пользовательского интерфейса Monkey [3] для запуска каждого приложения с сотнями случайных, но значимых входных данных. Неважно, какие приложения запускаются, важно лишь то, что они вызывают большое количество транзакций во многих системных службах, которые STATE S PY может автоматически отслеживать для анализа утечки состояния. Мы считаем, что анализ разнообразного набора транзакций из реального мира предпочтительнее сгенерированного набора надуманных тестовых случаев, которые могут быть нереалистичными. STATES PY очень прост в использовании с любой системой на базе Java и поддерживает системные службы Android «из коробки»; он может автоматически определять состояние покоя, точки входа в транзакцию и из какого приложения исходит данная транзакция. Более 96% сервисов в Android имеют одну и ту же структуру проектирования: основной класс сервисов реализует один или несколько интерфейсов-заглушек Binder IPC, которые автоматически генерируются системой сборки Android на основе спецификаций языка описания интерфейса. Заглушка — это абстрактный класс, который большинство служб либо напрямую наследуют, либо реализуют как анонимный внутренний класс; оба варианта обнаруживаются STATES PY. Как только класс-заглушка обнаружен, мы просто назначаем обработчик IPC Binder onTransact() в качестве его точки входа и отслеживаем его на предмет входящих транзакций. Все данные были собраны из стандартного AOSP под управлением Android Marshmallow 6.0.1 на смартфоне Nexus 5. 6.2 Утечка состояния широко распространена в Android Наш комплексный анализ системных служб Android показывает повсеместность и масштаб утечки состояния, как показано на рисунке 4. Утечка состояния настолько глубоко внедрена в службы Android, что наш инструмент не обнаружил утечки состояния менее чем в 6% случаев. из более чем 100 заглушек обработки транзакций (интерфейсов AIDL), которые мы проанализировали. Мы представляем результаты для каждой заглушки, а не для каждой службы из соображений детализации и точности, хотя большинство служб реализуют только одну заглушку. Хотя 76% заглушек служб имеют менее 10 отдельных изолированных состояний, некоторые из более крупных заглушек имеют гораздо больше состояний, что обычно масштабируется в зависимости от сложности реализуемой службы. Отдельное развернутое состояние относится к одному полю-члену в объекте службы, которое было изменено обработчиком транзакции. Некоторая утечка состояний относительно проста, но все же мешает достижению различных вычислительных целей. Например, обратные вызовы и параметры конфигурации делают невозможным миграцию процессов и виртуализацию этих сервисов. STATE S PY обнаружил утечку состояния в службах ClipboardService и AlarmManager-Service Android (среди прочих), что ставит под угрозу отказоустойчивость. Когда эти службы перезапускаются после сбоя, они перестают функционировать должным образом — копирование/вставка в буфер обмена и сигналы тревоги перестают работать — и приводят к загадочным сбоям пользовательских приложений. Если эти службы защищены от утечки состояния, эти службы могут быть должным образом восстановлены после сбоя, чтобы сохранить корректность приложения[17]. Другие случаи разливов в штатах являются более неожиданными и имеют сложные последствия, которые трудно обнаружить с помощью только ручного осмотра. Например, защищенное приложение может предложить пользователю ввести свой пароль, выполнив транзакциюverifyUnlock в KeyguardService. На первый взгляд можно подумать, что такая простая сделка свободна от вмешательства государства; однако STATE SPY показывает, что KeyguardService вызывает 3 случая утечки состояния — в форме логических переменных состояния — при обработке транзакцииverifyUnlock. Это может представлять собой потенциальную проблему безопасности: после того, как запрос пароля устанавливает эти логические значения, атака по точному времени может позволить вредоносному приложению обойти свой собственный запрос в случае сбоя исходного запроса, поскольку эти потерянные значения остаются. Еще одним неблагоприятным последствием утечки состояния является скрытый отказ функциональности, на которую приложения полагаются для обеспечения безопасности. Например, многие банковские приложения взаимодействуют с AlarmManagerService и передают его состояния, чтобы обеспечить автоматический выход из системы по тайм-ауту, который защищает личность пользователя и личную информацию в случае кражи или потери устройства. В случае сбоя этой службы возникает проблема безопасности: тайм-аут никогда не произойдет, и приложение не выйдет автоматически из системы, несмотря на то, что приложение не знает о сбое и все еще ожидает срабатывания тайм-аута.Чтобы глубже разобраться в утечке состояний в службах Android, мы случайным образом выбрали 60 транзакций службы из 21 службы (тот же набор из §5.5) для ручной классификации и анализа. Мы отнесли каждый случай утечки состояния к одной или нескольким из четырех категорий из §4 на основе семантики кода службы, вызывающей утечку. Эти категории не являются взаимоисключающими; например, все обратные вызовы, передаваемые в диспетчерскую службу, можно считать связанными со связью, но только часть из них предназначена для целей мультиплексирования. Во-первых, утечка состояния на слоях косвенности является наиболее распространенной (39%), поскольку многие службы Android существуют исключительно для обеспечения более простой высокоуровневой абстракции функции более низкого уровня. Во-вторых, утечка состояния в мультиплексорах встречается реже всего (21%), поскольку большая часть мультиплексирования устройств ввода-вывода реализуется на уровне аппаратной абстракции Android (под уровнем сервисов). В-третьих, утечка состояния в диспетчерах довольно распространена (36%), поскольку Android предлагает множество способов взаимодействия между приложениями и сервисами, многие из которых следуют модели программирования, управляемой событиями и насыщенной диспетчерами. Наконец, сотрудничество между объектами является довольно распространенной причиной утечки состояния (23%), поскольку многие службы Android работают вместе для достижения общих целей, что требует тесной синхронизации, описанной ниже. 6.3 Первичная и вторичная утечка состояния в Android До сих пор наш анализ был сосредоточен на понимании утечки состояния между парой объектов, от одного источника к одному месту назначения. Интересно, что мы обнаружили, что в дополнение к такой утечке первичного состояния мы также наблюдали вторичную утечку состояния в Android из исходной целевой службы в другую службу. Это межсервисное перераспределение происходит, когда одна служба вызывает изменения как в своем состоянии, так и в состоянии другой службы во время обработки транзакции. Определение 7. Вторичный разлив состояния происходит, когда обработка одной транзакции в сущности D1 приводит к разливу состояния из S _ Мы D1 D1 либо нашли и _ D2. D также 52 или D1. Состояния триггеров транзакций перетекли в другое состояние из транзакции 27 D1system _ D2, которая может вызвать разливы служб, исходное состояние, которое вызывает разлив вторичного состояния, нижняя граница. На рисунке 5 показано избранное подмножество этих сервисов и изображено только состояние состояния, а не зависимости или отношения использования. На этом графике показаны «горячие» сервисы, на которые приходится наибольшее количество государственных расходов, и показано, какие из них больше всего выиграют от редизайна программного обеспечения. В качестве примера вторичного сброса: приложения, которые взаимодействуют с UiModeManagerService для изменения пользовательского интерфейса, передают состояние конфигурации режима просмотра в этот сервис. Затем эта служба вызывает утечку вторичного состояния, вызывая изменение как состояния видимости StatusBarManagerService, так и состояния содержимого уведомления NotificationManagerService. Аналогичные события происходят, когда приложение отображает уведомление через NotificationManagerService, которое передает состояние в VibratorService и AudioService. Эти формы утечки состояния являются серьезными препятствиями для оперативного обновления или горячей замены этих сервисов, не говоря уже о снижении удобства обслуживания. 6.4 Пример использования Flux Чтобы дополнительно продемонстрировать полезность STATE S PY, мы сравниваем его результаты с ручным расширением системных служб Android с помощью Flux для поддержки миграции приложений. Flux [55] требует методов-декораторов, которые выборочно записывают и воспроизводят побочные эффекты метода службы (обработчика транзакций), эффективно решая проблему утечки состояния в этих методах, как показано ниже. Авторы Flux поделились с нами своим полным списком украшенных методов, который мы вручную проанализировали, чтобы определить основную истину о разливе состояния в каждом методе. Мы разработали инструментарий для отслеживания всех транзакций Binder, вызываемых набором приложений, и запускали STATE-S PY для каждой транзакции. Чтобы обеспечить справедливое сравнение, мы провели это исследование с использованием той же версии Android 4.4.2 и того же набора приложений, которые использовались при оценке Flux. Мы проигнорировали все сервисы, связанные с графикой, поскольку Flux обходит необходимость миграции состояний графических сервисов. и мы проигнорировали ActivityManagerService, поскольку Flux сильно настраивает свое поведение для целей миграции. Наша оценка охватила 113 уникальных транзакций Binder в 39 уникальных заглушках служб.Мы вручную проанализировали все 113 транзакций, чтобы оценить точность STATE SPY, и обнаружили 1 ложноположительный результат и 3 ложноотрицательных результата, вызванные неполной обработкой собственных методов. Из 113 методов транзакций 26 поддерживались декораторами Flux, а 87 — нет. Интересно, что 24 из этих 26 декорированных методов содержат утечку состояния, что подчеркивает сильную корреляцию между утечкой состояния в методах обслуживания и необходимостью понимать и дополнять эти методы обслуживания (т. е. обрабатывать остаточные зависимости) для обеспечения правильного поведения после миграции. Кроме того, STATE S PY обнаружил истинную утечку состояния в 18 из этих 87 неподдерживаемых методов, что указывает на потенциально некорректное поведение в приложении, мигрированном с помощью Flux. Например, утечка состояния в AppWidgetService может привести к тому, что виджеты приложения на главном экране больше не будут получать и отключаться. перенесенное приложение. Разлив состояния в двух методах TextServicesManagerService может привести к (i) сбою прогнозируемых текстовых предложений при вводе и (ii) потере уведомлений о смерти Binder, что означает, что приложения не будут знать, если служба дала сбой. Package-ManagerService содержит утечку состояния, которая может привести к тому, что компоненты приложения (например, службы, поставщики контента, действия), которые были включены/отключены на исходном устройстве, не будут правильно включены или отключены на целевом устройстве после миграции. Аналогичным образом, утечка состояния в методе set-AppCallback() службы NfcService может привести к потере связи перенесенных приложений, зависящих от NFC, с радиомодулем NFC целевого устройства. Хотя Flux, конечно, может добавить поддержку этих 18 методов, этот практический пример демонстрирует полезность инструмента STATE S PY в выявлении методов транзакций и распределенных состояний, которые препятствуют миграции приложений.

1.

Рекомендации по проектированию утечки состояний Наши результаты рисуют очень пессимистическую картину: утечка состояний широко распространена и глубока в операционных системах. Можно ли устранить государственный разлив? Хотя полный ответ на этот вопрос выходит за рамки данной статьи, мы предлагаем решения по устранению или уменьшению последствий утечки состояния, основываясь на классификации шаблонов проектирования §4. Мы совмещаем обсуждение мультиплексоров с уровнями косвенности и диспетчеров с сотрудничеством (коммуникацией), поскольку их решения взаимосвязаны. 7.1. Косвенное управление без потери состояния и мультиплексирование ресурсов, предоставляемых клиентом. Многие конструкции клиент-серверных объектов требуют, чтобы серверы предоставляли ресурсы (например, выделение памяти) для запросов клиентов, что является шаблоном для серверов микроядра и служб Android. Например, графическая служба Android SurfaceFlinger предлагает графические буферы каждому приложению по запросу, что представляет собой утечку состояния. Мы утверждаем, что ответственность за предоставление пространства памяти для операций сервера должна лежать на клиенте, заставляя клиента владеть и предоставлять ресурс в пределах границ своей сущности. Обратите внимание, что это не мешает объекту сервера устанавливать разрешения для этого ресурса, например, области памяти только для чтения в адресном пространстве клиента, которую сервер может изменять. Этот шаблон значительно уменьшает или устраняет утечку состояния, поскольку состояние не сохраняется и не изменяется на сервере; таким образом, независимо от того, что запрашивает один клиент, сервер не может причинить вред или использовать ресурсы другого клиента. Как упоминалось в §4.2, Nitpicker WM компании Genode [21] следует этому шаблону, требуя от клиентов выделять память для окон просмотра, управляемых сервером, а-ля CuriOS [16]. Отделение мультиплексирования от косвенного. Функциональность мультиплексирования ресурсов обычно сосуществует с косвенным. AlarmManagerService UsbService AudioService ActivityManagerService HdmiControlService PowerManagerService UserManagerService SensorService PackageManagerService разливает состояние между приложениями и системными службами в Android. поставщиков в одном лице, например, большинство драйверов устройств, объединяя их обязанности. Мы утверждаем, что эти два объекта следует разделить на физически отдельные сущности. Выделенный мультиплексор позволяет базовому объекту драйвера быть свободным от утечки состояния, если он реализован правильно (например, с использованием протоколов без сохранения состояния, приведенных ниже). Разлив состояния в выделенном мультиплексоре решить сложно, но его можно значительно уменьшить с помощью конструкций, которые задействуют ресурсы, принадлежащие клиенту (см. выше). Буферизация — хороший пример выделения функций мультиплексирования в независимый объект. Несколько клиентских приложений, которые хотят распечатать документы, отправляют их в каталог буферизации (мультиплексор), после чего только один драйвер принтера (уровень косвенности) получает доступ к буферным документам и записывает их на устройство принтера. Хотя на этапе удержания может временно произойти утечка состояний, эти состояния вскоре становятся внешними, как только водитель распечатывает документы. Укрепление состояния объекта. Состояния в программном объекте несколько эфемерны; их время жизни зависит от нестабильности их основного хранилища, например, регистров, памяти или вторичного хранилища. Отделяя время существования состояния от времени жизни содержащего его объекта, это состояние становится усиленным — если объект будет уничтожен или воссоздан, защищенное состояние (я) останется. Таким образом, как только государство становится более жестким, оно больше не способствует его размыванию. Усиление состояния проще всего достигается путем экстернализации, например, кэш файловой системы укрепляет состояние, записывая его на диск; существуют и другие подходы, такие как перемещение состояний из адресного пространства сущности. Фактически, мы исследовали возможность модернизации системных служб Android с помощью таких механизмов усиления состояния, чтобы уменьшить последствия утечки состояния и повысить отказоустойчивость [17]. Другим примером усиления защиты состояния является менеджер сеансов X, xsm, который постоянно сохраняет конфигурацию окон и детали организации, чтобы сохранить окна пользователя при входе в систему. 7.2 Безубыточная государственная коммуникация Модульность без взаимозависимости: Модульность часто объединяет разделение задач с развязкой и независимостью, но, как мы показали, сама по себе модульность не гарантирует уменьшения связанности или взаимозависимости, а также не исключает разливов состояния. Серверы MINIX 3 и другие объекты из §4.3 становятся жертвами этой проблемы модульности.Чтобы уменьшить утечку состояния, следует избегать модульных сущностей с тесно связанными зависимостями в пользу слабосвязанных, которые взаимодействуют по протоколам без сохранения состояния (ниже). Хотя разлив состояния можно рассматривать как форму связи данных и управления [36], связь просто необходима, но недостаточна для разлива состояния (§8). Если взаимозависимость или связь неизбежны, проектировщикам систем следует избегать репликации состояний, которые должны распространяться по всей системе при событиях синхронизации; вместо этого состояния должны быть ортогональными. Когда требуется репликация состояния, например, кэширование, один объект должен иметь возможность отслеживать распространение своих состояний на другие объекты, чтобы реплики могли обновляться. Модели чистой коммуникации. Простой способ уменьшить утечку состояния — избегать протоколов связи, которые полагаются на предварительную связь. Например, RESTful-коммуникация [22], используемая в сети, требует протоколов без сохранения состояния, то есть самодостаточных транзакций: вся информация, необходимая для обработки запроса, должна предоставляться вместе с этим запросом, что избавляет веб-сервер от необходимости хранить клиентские данные. данные, которые становятся государственной утечкой. Мы понимаем, что протоколы без сохранения состояния иногда могут быть непрактичными, особенно на более низких уровнях абстракции, поскольку протоколы работают с максимально возможной степенью детализации. Несмотря на это, все же есть ценные выводы: (i) самодостаточные транзакции предпочтительнее, и (ii) клиентские организации должны взять на себя ответственность за отслеживание собственного прогресса на стороне сервера. Кроме того, универсальные механизмы широковещания могут уменьшить утечку состояния, одинаково обрабатывая каждого клиента, устраняя необходимость в сервере для поддержания состояния, специфичного для клиента. Например, алгоритм хлебопекарни Лэмпорта [30] позволяет серверу избежать хранения очереди клиентов, назначая каждому клиенту номер и затем вызывая их одного за другим для доступа. Эта конструкция явно полезна для уменьшения утечки состояний в диспетчерах, а также применима к моделям издатель-подписчик. 8. Сопутствующие работы Хотя мы первые, кто, насколько нам известно, выявили и изучили проблему разлива государства, многие предыдущие работы признавали ее проблемы, но не смогли определить ее конкретно. Вместо этого они часто идут на все, чтобы лечить или обойти симптомы разлива государства. Поскольку в приведенных выше разделах подробно освещались такие работы, теперь мы сосредоточимся на работах, посвященных явлениям, связанным с разливом нефти, но отличным от него. Модульность. Поскольку утечка состояния происходит между двумя объектами или модулями, очевидно, что модульность является предпосылкой, а не решением проблемы утечки состояния. Таким образом, усилия по улучшению модульности ОС, например, Fluke OSKit [24], Knit [42], THINK [20] и OpenCom [15], сами по себе не уменьшают утечку состояний. Наша работа открывает двери для исследования особой формы модульности, при которой между модулями не происходит утечки состояний. Связывание модулей: Кстати, в работах по разработке программного обеспечения изучались и классифицировались различные формы связей и взаимодействий зависимостей между модулями [36, 44, 58, 33, 43]. Хотя утечка состояния часто попадает в один из шести типов связи данных и управления в [36], связь связана с передачей данных и управления между объектами, тогда как утечка состояния измеряет ее долгосрочные последствия; таким образом, связь необходима, но недостаточна для того, чтобы произошло разлив состояний. Например, параметр, который влияет только на временные переменные, например int b в L9 листинга 1, вызывает связывание, но не утечку состояния; таким образом, это не оказывает длительного воздействия на объект и не влияет на вышеупомянутые вычислительные цели. Информационный поток: утечка состояния связана с отслеживанием вредоносных данных и другими методами управления информационными потоками, что является хорошо изученной темой в системном программном обеспечении [59, 29, 60] и, в последнее время, в Android [8, 18]. Хотя в этих работах используются те же методы обнаружения, что и в STATE S PY, они в первую очередь касаются последствий для безопасности/конфиденциальности данных, распространяющихся через систему и утечек из дефектного объекта, а не того, вызывают ли эти данные важные изменения в объектах, которым они распространяются. . Другие работы исследуют более широкую картину того, как взаимодействие между несколькими объектами (компонентами Android) может вызвать уязвимости безопасности [13, 35, 56]. Эти инструменты не выявляют утечку информации со стороны государства, но дополняют ГОСУДАРСТВЕННУЮ ШПИОНУЮ и могут расширить ее сферу применения, выявляя более детальную и детальную цепочку взаимодействий между источниками, посредниками и объектами назначения.Проекты, которые могут уменьшить утечку состояния: без явного признания проблемы утечки состояния многие пытались разделить важные состояния в приложениях, например, Microreboot [12], и в компонентах ОС, например, CuriOS [16] и Barrelfish/DC [61]. ]. Эти конструкции могут неосознанно уменьшить утечку состояний, но их нелегко применить к существующим крупномасштабным ОС, таким как Android. Библиотечные операционные системы позволяют пользовательским приложениям указывать или предоставлять собственную реализацию данного сервиса или функции ОС для индивидуального использования [19, 41], потенциально уменьшая утечку состояния. Однако частный сервис для каждого приложения неэффективен, и как только реализация этого специального сервиса используется другими приложениями, он становится подвержен тому же утечке состояния, что и другие конструкции ОС. Аналогично, философия дизайна Unikernel упаковывает приложения, сервисы и ядро ​​в единое герметичное устройство [31], полностью минуя утечку состояния, поскольку все становится единым крупнозернистым объектом. Однако такая конструкция делает вышеупомянутые вычислительные цели либо очень трудными, либо совершенно невозможными из-за отсутствия гибкости программного обеспечения — все эти цели требуют слабосвязанных, независимых и заменяемых объектов ОС. Как упоминалось ранее, архитектуры RESTful, используемые в веб-сервисах [40, 39], устраняют утечку состояния на максимально возможном уровне детализации, но не имеют отношения к вычислительным целям на одной машине. Олссон [37] применил принципы RESTful к очень простому клиентскому API с неоднозначными результатами, уделяя больше внимания аспектам проектирования на стороне клиента, а не его влиянию на состояние и поведение сервера. 9. Заключительные замечания В этой работе мы определяем и идентифицируем утечку состояния как основную причину, по которой важные вычислительные задачи, такие как миграция процессов, изоляция и восстановление ошибок, оперативное обновление и горячая замена, трудно реализовать. Мы показываем, что важные шаблоны проектирования в системном программном обеспечении подвержены утечке состояния, и разрабатываем инструмент STATE S PY, который помогает разработчикам автоматически выявлять случаи утечки состояния в крупномасштабных программных системах. Применяя STATE SPY к системным службам Android, мы показываем распространенность и глубокую природу утечки состояния в них. Мы считаем, что по мере того, как программные системы становятся все более сложными и размерами, утечка состояний становится узким местом на пути к надежности, безопасности и масштабируемости. С помощью этой работы мы надеемся привлечь внимание сообщества к разливу состояний как к малоизученному и важному явлению в программных системах. БЛАГОДАРНОСТИ Мы благодарим авторов Flux [55] за обмен неопубликованными результатами, нашего пастыря доктора Дилму Да Силва и анонимных рецензентов за их отзывы. Эта работа была частично поддержана премией NSF CNS № 1422312 и приложением к ней REU. Ссылки [1] Проектирование архитектуры ОС Genode: интерфейсы и механизмы. http://genode.org/documentation/architecture/interfaces. Доступ: 22 февраля 2016 г. [2] Вызов приложений пользовательского пространства из ядра. https://www.ibm.com/developerworks/library/l-user-space-apps/. Доступ: 13 октября 2016 г. [3] Обезьяна-тренажер пользовательского интерфейса/приложений. https://разработчик. android.com/studio/test/monkey.html. Доступ: 10 октября 2016 г. [4] Рекомендации по безопасности X.Org: 9 декабря 2014 г. https: //www.x.org/wiki/Development/Security/ Advisory-2014-12-09/. Доступ: 11 октября 2016 г. [5] Г. Альтекар, И. Баграк, П. Бурштейн, А. Шульц. Opus: Онлайн-патчи и обновления для безопасности. В Proc. USENIX Security, 2005. [6] Дж. Андрус, К. Далл, А. В. Хоф, О. Лаадан и Дж. Ние. Cells: виртуальная архитектура мобильного смартфона. В Proc. ACM SOSP, 2011. [7] Дж. Арнольд и М. Ф. Каашук. Ksplice: автоматическое обновление ядра без перезагрузки. В Proc. ACM EuroSys, 2009. [8] С. Арцт, С. Растофер, К. Фриц, Э. Бодден, А. Бартель, Дж. Кляйн, Ю. Ле Траон, Д. Окто и П. МакДэниел. FlowDroid: точный контекстный, потоковый, полевой, объектно-чувствительный анализ с учетом жизненного цикла приложений Android. В Proc. ACM PLDI, 2014. [9] П. Бартон-Дэвис. Список рассылки ядра Linux: звонки. http://lkml.iu.edu/hypermail/linux/kernel/9809. 3/0922.html. Доступ: 13 октября 2016 г. [10] Боос К. StateSpy: веб-сайт государственного проекта по определению характеристик разливов. http://download.recg.org. [11] К. Боос, А. Амири Сани и Л. Чжун. Устранение переплетения состояний с помощью виртуализации служб мобильной ОС на основе контрольных точек. В Proc. ACM APSys, 2015. [12] Г. Кандеа, С. Кавамото, Ю. Фуджики, Г. Фридман и А. Фокс. Микроперезагрузка — метод дешевого восстановления. В Proc. USENIX OSDI, 2004. [13] Э. Чин, А. П. Фелт, К. Гринвуд и Д. Вагнер.Анализ взаимодействия между приложениями в Android. В Proc. ACM MobiSys, 2011. [14] Д.Д. Кларк. Структурирование систем с использованием апколлов. В Proc. ACM SOSP, 1985. [15] Г. Коулсон, Г. Блер, П. Грейс, Ф. Тайани, А. Джулия, К. Ли, Дж. Уэяма и Т. Сивахаран. Общая модель компонентов для создания системного программного обеспечения. Транзакции ACM в компьютерных системах, 2008. [16] Ф.М. Дэвид, Э.М. Чан, Дж. К. Карлайл и Р. Х. Кэмпбелл. CuriOS: повышение надежности за счет структуры операционной системы. В Proc. USENIX OSDI, 2008. [17] П. Донг. Уменьшение разделения судеб в программных системах за счет детальной проверки и восстановления. Магистерская диссертация, Университет Райса, 2016. [18] В. Энк, П. Гилберт, С. Хан, В. Тендулкар, Б.-Г. Чун, Л.П. Кокс, Дж. Юнг, П. МакДэниел и А.Н. Шет. TaintDroid: система отслеживания информационных потоков для мониторинга конфиденциальности на смартфонах в реальном времени. В Proc. USENIX OSDI, 2010. [19] Д. Р. Энглер, М. Ф. Каашук и Дж. О'Тул-младший. Экзоядро: архитектура операционной системы для управления ресурсами на уровне приложений. В Proc. АСМ СОСП, 1995. [20] Ж.-П. Фассино, Ж.-Б. Стефани, Дж. Л. Ловал и Г. Мюллер. ПОДУМАЙТЕ: программная среда для компонентных ядер операционных систем. В Proc. USENIX ATC, 2002. [21] Н. Феске и К. Хельмут. Руководство для придирок по безопасному графическому интерфейсу минимальной сложности. Технический отчет, Technische Universität Dresden, 2005. [22] Р. Филдинг. Изобразительное State Transfer. Архитектурные стили и проектирование архитектуры сетевого программного обеспечения, 2000. [23] Р.Т. Филдинг и Р.Н. Тейлор. Принципиальное проектирование современной веб-архитектуры. ACM Transactions on Internet Technology (TOIT), 2002. [24] Б. Форд, Г. Бэк, Г. Бенсон, Дж. Лепре, А. Лин и О. Шиверс. Flux OSKit: основа для исследования ядра и языка. В Proc. ACM SOSP, 1997. [25] К. Джуффрида, А. Куйстен и А. С. Таненбаум. Безопасное и автоматическое обновление операционных систем в режиме реального времени. В Proc. ACM ASPLOS, 2013. [26] Дж. Н. Гердер, Х. Бос, Б. Грас, П. Хомбург и А. С. Таненбаум. Minix 3: высоконадежная самовосстанавливающаяся операционная система. Обзор операционных систем ACM SIGOPS, 2006. [27] К. Хуэй, Дж. Аппаву, Р. Вишневски, М. Ауслендер, Д. Эдельсон, Б. Гамса, О. Кригер, Б. Розенбург и М. Штумм. Поддержка компонентов системного программного обеспечения с возможностью горячей замены. В Proc. ACM HotOS, 2001. [28] А. Кадав, М. Дж. Ренцельманн и М. М. Свифт. Детализированная отказоустойчивость с использованием контрольных точек устройства. В Proc. ACM ASPLOS, 2013. [29] М. Крон, А. Йип, М. Бродский, Н. Клиффер, М. Ф. Каашук, Э. Колер и Р. Моррис. Управление информационными потоками для стандартных абстракций ОС. В Proc. ACM SOSP, 2007. [30] Л. Лэмпорт. Новое решение проблемы параллельного программирования Дейкстры. Сообщения ACM, 1974. [31] А. Мадхавапедди, Р. Мортье, К. Ротсос, Д. Скотт, Б. Сингх, Т. Газаньер, С. Смит, С. Хэнд и Дж. Кроукрофт. Unikernels: библиотеки операционных систем для облака. В Proc. ACM ASPLOS, 2013. [32] К. Макрис и К.Д. Рю. Динамические и адаптивные обновления неактивных подсистем в ядрах стандартных операционных систем. В Proc. ACM EuroSys, 2007. [33] Н. Р. Мехта, Н. Медвидович и С. Фадке. К таксономии программных коннекторов. В Proc. ACM/IEEE ICSE, 2000. [34] Д.С. Милойчич, Ф. Дуглис, Ю. Пайндавейн, Р. Уиллер и С. Чжоу. Процесс миграции. АКМ Компьютер. Surv., 2000. [35] Д. Окто, П. МакДэниел, С. Джа, А. Бартель, Э. Бодден, Дж. Кляйн и Ю. Ле Траон. Эффективное сопоставление межкомпонентных связей в Android с помощью EPICC: важный шаг на пути к целостному анализу безопасности. В Proc. USENIX Security, 2013. [36] А. Дж. Оффутт, М. Дж. Харролд и П. Колте. Программная метрическая система для сопряжения модулей. Журнал систем и программного обеспечения, 1993. [37] Р. Олссон. Применение принципов REST к локальным клиентским API. Магистерская диссертация, Королевский технологический институт KTH, 2014 г. [38] С. Осман, Д. Субхравети, Г. Су и Дж. Ние. Проектирование и реализация Zap: системы миграции вычислительных сред. В Proc. USENIX OSDI, 2002. [39] К. Паутассо и Э. Уайльд. Почему сеть слабосвязана?: многогранный показатель для дизайна услуг. В Proc. WWW, 2009. [40] К. Паутассо, О. Циммерманн и Ф. Лейманн. Веб-сервисы RESTful против «больших» веб-сервисов: принятие правильного архитектурного решения. В Proc. WWW, 2008. [41] Д. Э. Портер, С. Бойд-Викайзер, Дж. Хауэлл, Р. Олински и Г. К. Хант. Переосмысление библиотеки ОС сверху вниз. В Proc. ACM ASPLOS, 2011. [42] А. Рид, М. Флатт, Л. Столлер, Ж. Лепро и Э. Эйде.Вязать: Компонентная композиция для системного программного обеспечения. В Proc. USENIX OSDI, 2000. [43] Н. Сангал, Э. Джордан, В. Синха и Д. Джексон. Использование моделей зависимостей для управления сложной архитектурой программного обеспечения. В Proc. ACM OOPLSA, 2005. [44] С. Р. Шах, Б. Джин, Д. Р. Райт, Г. З. Хеллер и А. Дж. Оффатт. Ремонтопригодность ядра Linux. IEE Proceedings-Software, 2002. [45] Р.В. Шайфлер и Дж. Геттис. Оконная система x. ACM Transactions on Graphics (TOG), 1986. [46] К. Сен. Конколическое тестирование. В Proc. IEEE/ACM ASE, 2007. [47] Р. Сетхи. Языки программирования: понятия и конструкции. 1996. [48] М. Синявин и А. Гоэль. Бесшовные обновления ядра. В Proc. IEEE/IFIP DSN, 2013. [49] К.А. Соулс, Дж. Аппаву, К. Хуэй, Р.В. Вишневски, Д. Да Силва, Г.Р. Гангер, О. Кригер, М. Штумм, М.А. Аусландер, М. Островски, Б. Розенбург и Дж. Ксенидис. Поддержка системы для онлайн-реконфигурации. В Proc. USENIX ATC, 2003. [50] BP Swift. Планирование пользовательского режима в MINIX 3. Технический отчет, Университет Врие, Амстердам, 2010. [51] М.М. Свифт, М. Аннамалай, Б.Н. Бершад и Х.М. Леви. Восстановление драйверов устройств. В Proc. USENIX OSDI, 2004. [52] М.М. Свифт, Б.Н. Бершад и Х.М. Леви. Повышение надежности стандартных операционных систем. В Proc. ACM SOSP, 2003. [53] П. Тульманн, Дж. Лепро, Б. Форд и М. Хиблер. Контрольная точка на уровне пользователя через экспортируемое состояние ядра. В Proc. IEEE Wrkshp. Объектно-ориентированная ориентация в операционных системах, 1996. [54] Р. Валле-Рай, П. Ко, Э. Ганьон, Л. Хендрен, П. Лам и В. Сундаресан. Soot — платформа оптимизации байт-кода Java. В Proc. CASCON, 1999. [55] А. Вант Хоф, Х. Джамджум, Дж. Ние и Д. Уильямс. Flux: многоповерхностные вычисления в Android. В Proc. ACM EuroSys, 2015. [56] Ф. Вэй, С. Рой, X. Оу и Робби. Amandroid: точная и общая платформа анализа межкомпонентного потока данных для проверки безопасности приложений Android. В Proc. ACM CCS, 2014. [57] М. Вайзер. Программная нарезка. В Proc. ACM/IEEE ICSE, 1981. [58] Л. Ю, С. Р. Шах, К. Чен, Г. З. Хеллер и Дж. Оффутт. Ремонтопригодность ядер операционных систем с открытым исходным кодом: сравнение Linux с FreeBSD, NetBSD и OpenBSD. Журнал систем и программного обеспечения, 2006. [59] Н. Зельдович, С. Бойд-Викайзер, Э. Колер и Д. Мазьер. Обеспечение явного потока информации в HiStar. В Proc. USENIX OSDI, 2006. [60] Н. Зельдович, С. Бойд-Викайзер и Д. Мазиер. Обеспечение безопасности распределенных систем с помощью управления информационными потоками. В Proc. USENIX NSDI, 2008. [61] Г. Зеллвегер, С. Гербер, К. Куртис и Т. Роско. Разделение ядер, ядер и операционных систем. В Proc. УСЕНИКС ОСДИ, 2014.
